---
title: "dos-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dos-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MTCP)
```

## DOS illustration 

Code for running for the illustrations

Parameters in the dense case
```{r illustration_set1, eval=FALSE}
set.seed(2)
n <- 100
mu <- 2
eps <- 0.2
```

Parameters in the sparse case
```{r illustration_set2, eval=FALSE}
set.seed(1)
n <- 100
mu <- 3
eps <- 0.05
```

Code for producing the plot

```{r illustration1, eval= FALSE }
p_seq <- sim_pval(n, 0, mu, eps, 0)
k <- n * eps
pch_type <- c(rep(4, k), rep(20, n - k))
ord <- order(p_seq)
col <- c(rep("red", k),rep("black", n - k))
col <- col[ord]
pch_type <- pch_type[ord]
p_seq <- sort(p_seq)

par(mar = c(5, 4, 4, 4) + 0.1)

plot(p_seq[1:(n/2)], axes = FALSE, ylab = "", xlab = "", pch = pch_type, col = col)
axis(2, ylim = c(0, 1), col = "black", las = 1)
mtext("p-value", side = 2, line = 2.5)
box()
par(new = TRUE)
plot(c(dos_fun(p_seq)$dos_seq, rep(0, n/2)), xlab = "", ylab = "", ylim = range(dos_fun(p_seq)$dos_seq),
    axes = FALSE, type = "l")
mtext("DOS sequence", side = 4, line = 2.5)
axis(4, ylim = range(dos_fun(p_seq, 1)$dos_seq), las = 1)
axis(1)
legend("bottomright", legend = c(expression(H[1]), expression(H[0])), col = c("red",
    "black"), pch = c(4, 20), cex = 0.8)
abline(v = which.max(dos_fun(p_seq)$dos_seq), lty = "dashed")
```



## DOS simulations ##

Function for comparing different methods. These methods are:

* **BH09** - From Cai, T. T., Sun, W., & Xia, Y. (2022). LAWS: A Locally Adaptive Weighting and Screening Approach to Spatial Multiple Testing. Journal of the American Statistical Association, 117(539), 1370–1383.
* **BOOTSTRAP** - Storey, J. D., Taylor, J. E., & Siegmund, D. (2004). Strong control, conservative point estimation and simultaneous conservative consistency of false discovery rates: a unified approach. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 66(1), 187–205.
* **FIX05** - Storey's estimator of the false null proportion with $\lambda=0.5$
* **FIXMED** - Storey's estimator of the false null proportion with $\lambda=p_{(n/2)}$
* **JD** - Jiang, H., & Doerge, R. W. (2008). Estimating the Proportion of True Null Hypotheses for Multiple Comparisons. Cancer Informatics, 6, 117693510800600. 
* **LLF_CONVEST** and **LLF_GRENANDER** - Langaas, M., Lindqvist, B. H., & Ferkingstad, E. (2005). Estimating the Proportion of True Null Hypotheses, with Application to DNA Microarray Data. Journal of the Royal Statistical Society. Series B (Statistical Methodology), 67(4), 555–572
* **LSL** - Benjamini, Y., & Hochberg, Y. (2000). On the Adaptive Control of the False Discovery Rate in Multiple Testing with Independent Statistics. Journal of Educational and Behavioral Statistics, 25(1), 60.
* **MGF** & **PRE** - Broberg, P. (2005). A comparative review of estimates of the proportion unchanged genes and the false discovery rate. BMC Bioinformatics, 6, 199. 
* **MR** - Meinshausen, N., & Rice, J. (2006). Estimating the proportion of false null hypotheses among a large number of independently tested hypotheses. Annals of Statistics, 34(1), 373–393. 
* **SMOOTHER** - Storey, J. D., & Tibshirani, R. (2003). Statistical significance for genomewide studies. Proceedings of the National Academy of Sciences, 100(16), 9440–9445.

```{r dependencies}
if (!requireNamespace("fdrtool", quietly = TRUE)) {
    install.packages("fdrtool", quietly = TRUE)
  }
if (!requireNamespace("qvalue", quietly = TRUE)) {
  BiocManager::install("qvalue")
}
if (!requireNamespace("limma", quietly = TRUE)) {
  BiocManager::install("limma")
}

library("fdrtool")
library("qvalue")
library("limma")
```


```{r complete testing function, eval = FALSE}
dos_test_gaussian <- function(n, eps, mu, N) {
  mat <- matrix(0, N, 14)
  colnames(mat) <- c("DOS1", "DOS05", "BH09", "BOOTSTRAP", "FIX05", "FIXMED",
                     "JD", "LLF_CONVEST", "LLF_GRENANDER", "LSL", "MGF", "MR",
                     "PRE", "SMOOTHER")
  df <- data.frame(mat)

  for (i in 1:N) {
    p_seq <- sort(sim_pval(n, 0, mu, eps, 0))
    
    df$DOS1[i] <- storey_pi1est(p_seq[dos_fun(p_seq,
                                              alpha = 1)$cp_loc], p_seq)$est
    df$DOS05[i] <- storey_pi1est(p_seq[dos_fun(p_seq,
                                              alpha = 1/2)$cp_loc], p_seq)$est

    df$BH09[i] <- storey_pi1est(max(which(sort(p_seq) <= 0.9*(1:n)/n))/n, p_seq)$est
    df$FIX05[i] <- storey_pi1est(0.5, p_seq)$est
    df$FIXMED[i] <- storey_pi1est(p_seq[n/2], p_seq)$est
    df$BOOTSTRAP[i] <- 1 - qvalue::pi0est(p_seq, pi0.method = "bootstrap")$pi0
    df$SMOOTHER[i] <- 1 - qvalue::pi0est(p_seq, pi0.method = "smoother")$pi0
    df$LSL[i] <- 1 - fdrtool::pval.estimate.eta0(p_seq, method = "adaptive",
                                                 diagnostic.plot = FALSE)
    df$PRE[i] <- 1 - PRE_est(p_seq)
    df$MGF[i] <- 1 - MGF_est(p_seq)
    df$JD[i] <- 1 - min(1, JD_est(p_seq, 100))
    df$LLF_GRENANDER[i] <- 1 - LLF_Grenander_est(p_seq)
    df$LLF_CONVEST[i] <- 1 - limma::convest(p_seq)
    df$MR[i] <- MR_est(p_seq)
  }
  
  res <- rbind(apply(df, MARGIN = 2, FUN = mean),
               apply(df, MARGIN = 2, FUN = sd))
  res[1, ] <- res[1, ] - eps
  res <- rbind(res, sqrt(res[1, ]^2 + res[2, ]^2))
  rownames(res) <- c("BIAS", "SD", "RMSE")
  boxplot(df, ylab = expression(hat(pi)[1]))
  abline(h = eps)
  
  return((res))
}

```

The following code produces a latex table of simulation results for sample of size $n=1000$ for various $\mu$ and $\varepsilon$ values and the simulations are based on $N=200$ repetitions.


```{r simulations, eval=FALSE}
set.seed(10)
n_seq <- rep(1000, 8)
eps_seq <- c(0.01, 0.03, 0.05, 0.1, 0.1, 0.2, 0.2, 0.3)
mu_seq <- c(3.5, 3.5, 3, 2, 3, 2, 3, 3)

table_list <- list()
for (i in 1:length(n_seq)) {
  table_list[[i]] <- round(dos_test_gaussian(n_seq[i], eps_seq[i],
                                             mu_seq[i], 200) * n_seq[i], 1)
  rownames(table_list[[i]]) <- NULL
}

combined_table <- do.call(rbind, table_list)
row_names <- as.data.frame(rep(c("BIAS", "SD", "RMSE"), length(n_seq)))
colnames(row_names) <- ""
combined_table <- cbind(row_names, combined_table)

add_rows <- list()
add_rows$pos <- as.list(3 * (1:length(n_seq) - 1))
mu_info <- paste("mu =", mu_seq)
eps_info <- paste("eps =", eps_seq)
add_rows$command <- paste("\\hline\n", "\\multicolumn{14}{c}{",
                          mu_info, ",", eps_info, "} \\\\\\hline ")
print(xtable(combined_table), add.to.row = add_rows, include.rownames = FALSE)

```


```{r small sample testing function, eval = FALSE}
dos_test_gaussian_small=function(n,eps,mu,N)
{
  mat <- matrix(0, N, 10)
  colnames(mat)=c("DOS1", "DOS05", "BH09", "FIX05", "FIXMED", "JD", "LLF_CONVEST",
                   "LSL", "MGF", "MR")
  
  df <- data.frame(mat)

  for (i in 1:N) {
    p_seq <- sort(sim_pval(n, 0, mu, eps, 0))
    
    df$DOS1[i] <- storey_pi1est(p_seq[dos_fun(p_seq,
                                              alpha = 1)$cp_loc], p_seq)$est
    df$DOS05[i] <- storey_pi1est(p_seq[dos_fun(p_seq,
                                              alpha = 1/2)$cp_loc], p_seq)$est

    df$BH09[i] <- storey_pi1est(max(which(sort(p_seq) <= 0.9*(1:n)/n))/n, p_seq)$est
    df$FIX05[i] <- storey_pi1est(0.5, p_seq)$est
    df$FIXMED[i] <- storey_pi1est(p_seq[n/2], p_seq)$est
    df$LSL[i] <- 1 - fdrtool::pval.estimate.eta0(p_seq, method = "adaptive",
                                                 diagnostic.plot = FALSE)
    df$MGF[i] <- 1 - MGF_est(p_seq)
    df$JD[i] <- 1 - min(1, JD_est(p_seq, 100))
    df$LLF_CONVEST[i] <- 1 - limma::convest(p_seq)
    df$MR[i] <- MR_est(p_seq)
  }
  
  res <- rbind(apply(df, MARGIN = 2, FUN = mean),
               apply(df, MARGIN = 2, FUN = sd))
  res[1, ] <- res[1, ] - eps
  res <- rbind(res, sqrt(res[1, ]^2 + res[2, ]^2))
  rownames(res) <- c("BIAS", "SD", "RMSE")
  boxplot(df, ylab = expression(hat(pi)[1]))
  abline(h = eps)
  
  return((res))
}
```

The following code produces a latex table of simulation results for different small sample sizes $n$ and for various $\mu$ and $\varepsilon$ values. The simulations are based on $N=200$ repetitions.

```{r small sample simulations, eval = FALSE}
n_seq=c(50,50,50,100,100,100,100)
eps_seq=c(0.1,0.2,0.4,0.05,0.1,0.2,0.4)
mu_seq=c(3,2,2,3,3,2,2)
set.seed(20)

table_list <- list()
for (i in 1:length(n_seq)) {
  table_list[[i]] <- round(dos_test_gaussian_small(n_seq[i], eps_seq[i],
                                             mu_seq[i], 200) * n_seq[i], 1)
  rownames(table_list[[i]]) <- NULL
}

combined_table <- do.call(rbind, table_list)
row_names <- as.data.frame(rep(c("BIAS", "SD", "RMSE"), length(n_seq)))
colnames(row_names) <- ""
combined_table <- cbind(row_names, combined_table)

add_rows <- list()
add_rows$pos <- as.list(3 * (1:length(n_seq) - 1))
mu_info <- paste("mu =", mu_seq)
eps_info <- paste("eps =", eps_seq)
add_rows$command <- paste("\\hline\n", "\\multicolumn{10}{c}{",
                          mu_info, ",", eps_info, "} \\\\\\hline ")
print(xtable(combined_table), add.to.row = add_rows, include.rownames = FALSE)
```

## DOS - superuniform p-values 

The following code produces plots that compare the false null proportion estimator based on the randomised p-values and the DOS change-point estimator

```{r superuniform}
r <- 1:10
pi1 <- 0.25
rho <- 0.25
n <- 100
N <- 10000
dos1_cp_est <- rep(0, N)
dos12_cp_est <- rep(0, N)
hd_est_seq <- rep(0, N)
storey12_est <- rep(0, N)
max_spac_est <- rep(0, N)

arr <- array(
  data = rep(0, 3 * 4 * length(r)),
  dim = c(3, 4, length(r)),
  dimnames = list(
    c("BIAS", "SD", "MSE"),
    c("DOS-1", "DOS-1/2", "HD", "ST-1/2"),
    1:length(r)
  )
)

for (i in 1:length(r)) {
  for (j in 1:N) {
    p_seq <- sort(sim_pval(n, -0.2 * r[i], 1 + 0.25 * r[i], pi1, rho))
    dos1_cp_est[j] <- dos_fun(p_seq)$cp_loc / n
    dos12_cp_est[j] <- dos_fun(p_seq, 1/2)$cp_loc / n
    hd_est_seq[j] <- hd_est(p_seq)$pi1_est
    storey12_est[j] <- storey_pi1est(0.5, p_seq)$est
  }
  
  arr["BIAS", "DOS-1", i] <- mean(dos1_cp_est) - pi1
  arr["BIAS", "DOS-1/2", i] <- mean(dos12_cp_est) - pi1
  arr["BIAS", "HD", i] <- mean(hd_est_seq) - pi1
  arr["BIAS", "ST-1/2", i] <- mean(storey12_est) - pi1
  
  arr["SD", "DOS-1", i] <- sd(dos1_cp_est)
  arr["SD", "DOS-1/2", i] <- sd(dos12_cp_est)
  arr["SD", "HD", i] <- sd(hd_est_seq)
  arr["SD", "ST-1/2", i] <- sd(storey12_est)
  
  arr["MSE", , i] <- arr["SD", , i]^2 + arr["BIAS", , i]^2
}

mat <- t(arr["BIAS", 1:3, ])
matplot(mat + pi1, type = "b", xlab = "r", ylab = "", pch = 1:3, ylim = c(0, 2 * pi1), main = "MEAN")
abline(h = pi1)
legend("topright", colnames(mat), col = seq_len(ncol(mat)), pch = 1:4)

mat <- t(arr["SD", 1:3, ])
matplot(mat, type = "b", pch = 1:3, main = "SD", xlab = "r", ylab = "")
legend("topright", colnames(mat), col = seq_len(ncol(mat)), pch = 1:3)

mat <- t(arr["MSE", 1:3, ])
matplot(mat, type = "b", pch = 1:3, main = "MSE", xlab = "r", ylab = "")
legend("topright", colnames(mat), col = seq_len(ncol(mat)), pch = 1:3)
```

## DOS - FDR control

In this section we recreate the Figures 2, 3 and 4 from Blanchard, G., & Roquain, É. (2009). Adaptive false discovery rate control under independence and dependence. Journal of Machine Learning Research, 10, 2837–2871. We only include the adaptive procedures using Storey-based estimators and the DOS estimator of the proportion.

The following code produces 3 figures, showing the average proportion estimates, FDR and power of different adaptive BH methods as a function of the true null proportion. 

```{r fdr control pi0, eval = FALSE}
n <- 100
N <- 10000
mu <- 3
pi0 <- 0.5 + 0.5 * (1:15-1) / 15
rho <- 0.5
alpha <- 0.05
arr <- array(data = rep(0, 3 * 6 * length(pi0)),
             dim = c(3, 6, length(pi0)),
             dimnames = list(c("pi0est", "FDR", "power"),
                             c("DOS-1", "DOS-1/2", "oracle", "ST-alpha", "ST-MED", "ST-1/2"),
                             pi0))

div <- function(x, y) {
  ifelse(y == 0, 1, x / y)
}

for (j in 1:length(pi0)) {
  
  pi0est_dos1 <- pi0est_dos12 <- pi0est_alpha <- pi0est_12 <- pi0est_med <- rep(0, N)
  fdr_dos1 <- fdr_dos12 <- fdr_alpha <- fdr_oracle <- fdr_12 <- fdr_med <- rep(0, N)
  power_dos1 <- power_dos12 <- power_alpha <- power_oracle <- power_12 <- power_med <- rep(0, N)
  stop_med <- stop_dos <- rep(0, N)
  
  for (i in 1:N) {
    
    if (rho > 0) {
      eps <- sqrt(rho) * rnorm(1) + sqrt(1 - rho) * rnorm(n)
    } else {
      eps <- rnorm(n)
    }
    
    x <- eps + c(rep(0, floor(pi0[j] * n)), rep(mu, n - floor(n * pi0[j])))
    sig <- c(rep(0, floor(pi0[j] * n)), rep(1, n - floor(pi0[j] * n)))
    sig <- sig[order(1 - pnorm(x))]
    p_seq <- sort(1 - pnorm(x))
    
    pi0est_dos1[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1)$cp_loc], p_seq)$est
    pi0est_dos12[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1/2)$cp_loc], p_seq)$est
    pi0est_alpha[i] <- 1 - storey_pi1est(alpha, p_seq, mod = TRUE)$est
    pi0est_12[i] <- 1 - storey_pi1est(1/2, p_seq, mod = TRUE)$est
    pi0est_med[i] <- 1 - storey_pi1est(p_seq[n/2], p_seq, mod = TRUE)$est
    
    stop_med[i] <- p_seq[n/2]
    stop_dos[i] <- p_seq[dos_fun(p_seq)$cp_loc]
    
    abh_dos1 <- bh_adaptive(p_seq, pi0est_dos1[i], alpha, sig)
    fdr_dos1[i] <- abh_dos1$fdr
    power_dos1[i] <- abh_dos1$power
    
    abh_dos12 <- bh_adaptive(p_seq, pi0est_dos12[i], alpha, sig)
    fdr_dos12[i] <- abh_dos12$fdr
    power_dos12[i] <- abh_dos12$power
    
    abh_alpha <- bh_adaptive(p_seq, pi0est_alpha[i], alpha, sig)
    fdr_alpha[i] <- abh_alpha$fdr
    power_alpha[i] <- abh_alpha$power
    
    abh_oracle <- bh_adaptive(p_seq, pi0[j], alpha, sig)
    fdr_oracle[i] <- abh_oracle$fdr
    power_oracle[i] <- abh_oracle$power
    
    abh_12 <- bh_adaptive(p_seq, pi0est_12[i], alpha, sig)
    fdr_12[i] <- abh_12$fdr
    power_12[i] <- abh_12$power
    
    abh_med <- bh_adaptive(p_seq, pi0est_med[i], alpha, sig)
    fdr_med[i] <- abh_med$fdr
    power_med[i] <- abh_med$power
  }
  
  arr["pi0est", "DOS-1", toString(pi0[j])] <- mean(pi0est_dos1)
  arr["pi0est", "DOS-1/2", toString(pi0[j])] <- mean(pi0est_dos12)
  arr["pi0est", "ST-alpha", toString(pi0[j])] <- mean(pi0est_alpha)
  arr["pi0est", "oracle", toString(pi0[j])] <- pi0[j]
  arr["pi0est", "ST-1/2", toString(pi0[j])] <- mean(pi0est_12)
  arr["pi0est", "ST-MED", toString(pi0[j])] <- mean(pi0est_med)
  
  arr["FDR", "DOS-1", toString(pi0[j])] <- mean(fdr_dos1)
  arr["FDR", "DOS-1/2", toString(pi0[j])] <- mean(fdr_dos12)
  arr["FDR", "ST-alpha", toString(pi0[j])] <- mean(fdr_alpha)
  arr["FDR", "oracle", toString(pi0[j])] <- mean(fdr_oracle)  
  arr["FDR", "ST-1/2", toString(pi0[j])] <- mean(fdr_12) 
  arr["FDR", "ST-MED", toString(pi0[j])] <- mean(fdr_med) 

  
  arr["power", "DOS-1", toString(pi0[j])] <- mean(div(power_dos1, power_oracle))
  arr["power", "DOS-1/2", toString(pi0[j])] <- mean(div(power_dos12, power_oracle))
  arr["power", "ST-alpha", toString(pi0[j])] <- mean(div(power_alpha, power_oracle))
  arr["power", "oracle", toString(pi0[j])] <- mean(div(power_oracle, power_oracle))
  arr["power", "ST-1/2", toString(pi0[j])] <- mean(div(power_12, power_oracle))
  arr["power", "ST-MED", toString(pi0[j])] <- mean(div(power_med, power_oracle))
  
}

mat_pi0 <- t(arr["pi0est", , ])
matplot(pi0, mat_pi0, type = "b", pch = 1:6, ylab = expression(hat(pi)[0]), xlab= expression(pi[0]), main = "Average proportion estimates")
legend("bottomright", colnames(mat_pi0), col = seq_len(ncol(mat_pi0)), cex = 0.8, pch=1:6)

mat_fdr <- t(arr["FDR", , ])
matplot(pi0, mat_fdr, type = "b", pch = 1:6, main = "FDR", ylab = "",  xlab= expression(pi[0]))
legend("topleft", colnames(mat_fdr), col = seq_len(ncol(mat_fdr)), cex = 0.8, pch = 1:6)
abline(h = alpha)

mat_power <- t(arr["power", , ])
matplot(pi0, mat_power, type = "b", pch = 1:6, main = "Relative power", ylab = "", xlab= expression(pi[0]))
legend("topleft", colnames(mat_power), col = seq_len(ncol(mat_power)), cex = 0.8, pch = 1:6)
```

The following code produces 3 figures, showing the average proportion estimates, FDR and power of different adaptive BH methods as a function of the mean under the alternative.

```{r fdr control mu, eval = FALSE}
alpha <- 0.05
rho <- 0.5
mu <- seq(1, 5.5, by = 0.5)
pi0 <- 0.75

arr <- array(
  data = rep(0, 3 * 6 * length(mu)),
  dim = c(3, 6, length(mu)),
  dimnames = list(
    c("pi0est", "FDR", "power"),
    c("DOS-1", "DOS-1/2", "oracle", "ST-alpha", "ST-MED", "ST-1/2"),
    mu
  )
)

N <- 10000

for (j in 1:length(mu)) {
  
  pi0est_dos1 <- pi0est_dos12 <- pi0est_alpha <- pi0est_12 <- pi0est_med <- rep(0, N)
  fdr_dos1 <- fdr_dos1 <- fdr_alpha <- fdr_oracle <- fdr_12 <- fdr_med <- rep(0, N)
  power_dos <- power_alpha <- power_oracle <- power_12 <- power_med <- rep(0, N)
  
  n <- 100
  
  for (i in 1:N) {
    if (rho > 0) {
      eps <- sqrt(rho) * rnorm(1) + sqrt(1 - rho) * rnorm(n)
    } else {
      eps <- rnorm(n)
    }
    
    x <- eps + c(rep(0, floor(pi0 * n)), rep(mu[j], n - floor(n * pi0)))
    sig <- c(rep(0, floor(pi0 * n)), rep(1, n - floor(pi0 * n)))
    sig <- sig[order(1 - pnorm(x))]
    p_seq <- sort(1 - pnorm(x))
    
    pi0est_dos1[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1)$cp_loc], p_seq)$est
    pi0est_dos12[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1/2)$cp_loc], p_seq)$est
    pi0est_alpha[i] <- 1 - storey_pi1est(alpha, p_seq, mod = TRUE)$est
    pi0est_12[i] <- 1 - storey_pi1est(1/2, p_seq, mod = TRUE)$est
    pi0est_med[i] <- 1 - storey_pi1est(p_seq[n/2], p_seq, mod = TRUE)$est
    
    abh_dos1 <- bh_adaptive(p_seq, pi0est_dos1[i], alpha, sig)
    fdr_dos1[i] <- abh_dos1$fdr
    power_dos1[i] <- abh_dos1$power
    
    abh_dos12 <- bh_adaptive(p_seq, pi0est_dos12[i], alpha, sig)
    fdr_dos12[i] <- abh_dos12$fdr
    power_dos12[i] <- abh_dos12$power
    
    abh_alpha <- bh_adaptive(p_seq, pi0est_alpha[i], alpha, sig)
    fdr_alpha[i] <- abh_alpha$fdr
    power_alpha[i] <- abh_alpha$power
    
    abh_oracle <- bh_adaptive(p_seq, pi0, alpha, sig)
    fdr_oracle[i] <- abh_oracle$fdr
    power_oracle[i] <- abh_oracle$power
    
    abh_12 <- bh_adaptive(p_seq, pi0est_12[i], alpha, sig)
    fdr_12[i] <- abh_12$fdr
    power_12[i] <- abh_12$power
    
    abh_med <- bh_adaptive(p_seq, pi0est_med[i], alpha, sig)
    fdr_med[i] <- abh_med$fdr
    power_med[i] <- abh_med$power
  }
  
  arr["pi0est", "DOS-1", toString(mu[j])] <- mean(pi0est_dos1)
  arr["pi0est", "DOS-1/2", toString(mu[j])] <- mean(pi0est_dos12)
  arr["pi0est", "ST-alpha", toString(mu[j])] <- mean(pi0est_alpha)
  arr["pi0est", "oracle", toString(mu[j])] <- pi0
  arr["pi0est", "ST-1/2", toString(mu[j])] <- mean(pi0est_12)
  arr["pi0est", "ST-MED", toString(mu[j])] <- mean(pi0est_med)
  
  arr["FDR", "DOS-1", toString(mu[j])] <- mean(fdr_dos1)
  arr["FDR", "DOS-1/2", toString(mu[j])] <- mean(fdr_dos12)
  arr["FDR", "ST-alpha", toString(mu[j])] <- mean(fdr_alpha)
  arr["FDR", "oracle", toString(mu[j])] <- mean(fdr_oracle)
  arr["FDR", "ST-1/2", toString(mu[j])] <- mean(fdr_12)
  arr["FDR", "ST-MED", toString(mu[j])] <- mean(fdr_med)
  
  arr["power", "DOS-1", toString(mu[j])] <- mean(div(power_dos1, power_oracle))
  arr["power", "DOS-1/2", toString(mu[j])] <- mean(div(power_dos12, power_oracle))
  arr["power", "ST-alpha", toString(mu[j])] <- mean(div(power_alpha, power_oracle))
  arr["power", "oracle", toString(mu[j])] <- mean(div(power_oracle, power_oracle))
  arr["power", "ST-1/2", toString(mu[j])] <- mean(div(power_12, power_oracle))
  arr["power", "ST-MED", toString(mu[j])] <- mean(div(power_med, power_oracle))
}

mat_pi0 <- t(arr["pi0est", , ])
matplot(mu, mat_pi0, type = "b", pch = 1:6, xlab = expression(mu), ylab = expression(hat(pi)[0]), main = "Average proportion estimates")
legend("topright", colnames(mat_pi0), col = seq_len(ncol(mat_pi0)), cex = 0.8, pch= 1:6)

mat_fdr <- t(arr["FDR", , ])
matplot(mu, mat_fdr, type = "b", xlab = expression(mu), pch = 1:6, main = "FDR", ylab = "")
legend("topleft", colnames(mat_fdr), col = seq_len(ncol(mat_fdr)), cex = 0.8, pch = 1:6)
abline(h = alpha)

mat_power <- t(arr["power", , ])
matplot(mu, mat_power, type = "b", xlab = expression(mu), pch = 1:6, main = "Relative power", ylab = "")
legend("topleft", colnames(mat_power), col = seq_len(ncol(mat_power)), cex = 0.8, pch = 1:6)
```
The following code produces 3 figures, showing the average proportion estimates, FDR and power of different adaptive BH methods as a function of the correlation coefficient $\rho$.

```{r fdr control rho, eval = FALSE}
rho <- (1:31 - 1) / 30
pi0 <- 0.75
mu <- 3
n <- 100
N <- 1000
arr <- array(
  data = rep(0, 3 * 6 * length(rho)),
  dim = c(3, 6, length(rho)),
  dimnames = list(
    c("pi0est", "FDR", "power"),
    c("DOS-1", "DOS-1/2", "oracle", "ST-alpha", "ST-MED", "ST-1/2"),
    rho
  )
)

for (j in 1:length(rho)) {
  
  pi0est_dos <- pi0est_alpha <- rep(0, N)
  fdr_dos <- fdr_alpha <- fdr_oracle <- rep(0, N)
  power_dos <- power_alpha <- power_oracle <- rep(0, N)
  
  for (i in 1:N) {
    if (rho[j] > 0) {
      eps <- sqrt(rho[j]) * rnorm(1) + sqrt(1 - rho[j]) * rnorm(n)
    } else {
      eps <- rnorm(n)
    }
    
    x <- eps + c(rep(0, floor(pi0 * n)), rep(mu, n - floor(n * pi0)))
    sig <- c(rep(0, floor(pi0 * n)), rep(1, n - floor(pi0 * n)))
    sig <- sig[order(1 - pnorm(x))]
    p_seq <- sort(1 - pnorm(x))
    
    pi0est_dos1[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1)$cp_loc], p_seq)$est
    pi0est_dos12[i] <- 1 - storey_pi1est(p_seq[dos_fun(p_seq, alpha = 1/2)$cp_loc], p_seq)$est
    pi0est_alpha[i] <- 1 - storey_pi1est(alpha, p_seq, mod = TRUE)$est
    pi0est_12[i] <- 1 - storey_pi1est(1/2, p_seq, mod = TRUE)$est
    pi0est_med[i] <- 1 - storey_pi1est(p_seq[n/2], p_seq, mod = TRUE)$est
    
    abh_dos <- bh_adaptive(p_seq, pi0est_dos[i], alpha, sig)
    fdr_dos[i] <- abh_dos$fdr
    power_dos[i] <- abh_dos$power

    abh_alpha <- bh_adaptive(p_seq, pi0est_alpha[i], alpha, sig)
    fdr_alpha[i] <- abh_alpha$fdr
    power_alpha[i] <- abh_alpha$power
    
    abh_oracle <- bh_adaptive(p_seq, pi0, alpha, sig)
    fdr_oracle[i] <- abh_oracle$fdr
    power_oracle[i] <- abh_oracle$power
    
    abh_12 <- bh_adaptive(p_seq, pi0est_12[i], alpha, sig)
    fdr_12[i] <- abh_12$fdr
    power_12[i] <- abh_12$power
    
    abh_med <- bh_adaptive(p_seq, pi0est_med[i], alpha, sig)
    fdr_med[i] <- abh_med$fdr
    power_med[i] <- abh_med$power
  }
  
  arr["pi0est", "DOS-1", toString(rho[j])] <- mean(pi0est_dos1)
  arr["pi0est", "DOS-1/2", toString(rho[j])] <- mean(pi0est_dos12)
  arr["pi0est", "ST-alpha", toString(rho[j])] <- mean(pi0est_alpha)
  arr["pi0est", "oracle", toString(rho[j])] <- pi0
  arr["pi0est", "ST-1/2", toString(rho[j])] <- mean(pi0est_12)
  arr["pi0est", "ST-MED", toString(rho[j])] <- mean(pi0est_med)
  
  arr["FDR", "DOS-1", toString(rho[j])] <- mean(fdr_dos1)
  arr["FDR", "DOS-1/2", toString(rho[j])] <- mean(fdr_dos12)
  arr["FDR", "ST-alpha", toString(rho[j])] <- mean(fdr_alpha)
  arr["FDR", "oracle", toString(rho[j])] <- mean(fdr_oracle)
  arr["FDR", "ST-1/2", toString(rho[j])] <- mean(fdr_12)
  arr["FDR", "ST-MED", toString(rho[j])] <- mean(fdr_med)
  
  arr["power", "DOS-1", toString(rho[j])] <- mean(div(power_dos1, power_oracle))
  arr["power", "DOS-1/2", toString(rho[j])] <- mean(div(power_dos12, power_oracle))
  arr["power", "ST-alpha", toString(rho[j])] <- mean(div(power_oracle, power_alpha))
  arr["power", "oracle", toString(rho[j])] <- mean(div(power_oracle, power_oracle))
  arr["power", "ST-1/2", toString(rho[j])] <- mean(div(power_oracle, power_12))
  arr["power", "ST-MED", toString(rho[j])] <- mean(div(power_oracle, power_med))
}

mat_pi0 <- t(arr["pi0est", , ])
matplot(rho, mat_pi0, type = "b", xlab = expression(rho), pch = 1:6, ylab = expression(hat(pi)[0]), main = "Average proportion estimates")
legend("topright", colnames(mat_pi0), col = seq_len(ncol(mat_pi0)), cex = 0.8, pch = 1:6)

mat_fdr <- t(arr["FDR", , ])
matplot(rho, mat_fdr, type = "b", xlab = expression(rho), pch = 1:6, main = "FDR", ylab = "")
legend("topleft", colnames(mat_fdr), col = seq_len(ncol(mat_fdr)), cex = 0.8, pch = 1:6)
abline(h = alpha)

mat_power <- t(arr["power", , ])
matplot(rho, mat_power, type = "b", xlab = expression(rho), pch = 1:6, main = "Relative power", ylab = "")
legend("topleft", colnames(mat_power), col = seq_len(ncol(mat_power)), cex = 0.8, pch = 1:6)
```
